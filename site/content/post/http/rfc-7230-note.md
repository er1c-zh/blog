---
title: "rfc7230笔记"
date: 2021-07-22T14:55:02+08:00
draft: true
---

本文根据rfc文档的章节划分记录相关笔记。

<!--more-->

# 第一节 简介

HTTP协议是一种无状态的、应用层的、基于请求/响应构建的协议，
通过可扩展的语义的自描述的载荷来满足多变的基于网络的超文本信息系统的交互需求。

rfc7230是完整介绍HTTP/1.1的一系列文档的第一篇，
主要介绍了消息内容的语法和路由相关的内容。

HTTP协议是一个用于信息系统的通用性接口协议，
这意味着使用协议的双方不需要关心和了解对方的具体实现，
除此之外，HTTP协议的任意请求可以被看作是独立的，
这也是无状态性质的体现。

除了直接的连接客户端与服务端，
HTTP也被设计作为任意的其他协议的中间协议，
可以连接支持不同协议的信息系统。

因为这种多变性，所以协议无法详细的定义如何处理一个请求，
作为取代，
转而定义信息的语法、每次交流的目的、以及接收者被期望作出的响应。

稍为具体的，本文档介绍了协议会引用的结构，
定义了http、https和URI，
描述了总体的网络操作和链接管理，
以及定义了每个报文切分与转发的规则。

这些工作的目的是希望在独立于报文内容的情况下，
定义所有用于处理报文的必要的机制。
具体的，就是定义了处理报文和转发报文的所有要求。

# 2 Architecture 结构

## 2.1 客户端、服务端与报文

HTTP协议是一个无状态的请求响应协议，
通过交换报文来完成交互操作，
依赖底层的可靠传输链接。

HTTP的**客户端**指能够出于向服务端发送若干HTTP请求的目的而建立链接的程序；
**服务端**指能够接受链接来为HTTP请求提供服务，发送响应的程序。

**用户代理** *(User-Agent)* 指的是任意的能够发送请求的HTTP客户端程序。

**源服务器** *(Origin Server)* 指的是最源头、权威的能够服务该请求的资源的服务端程序。

HTTP依赖**统一资源描述符** *(Uniform Resource Identifier, URI)* 来指明请求的资源；
报文的格式类似于**Multipurpose Internet Mail Extensions, MIME**使用的格式。

## 2.2 实现的分歧

## 2.3 Intermediaries 中间件

协议允许使用若干中间件和链接来服务一个请求，
（因为**无状态**，）多个请求不要求也不保证经历相同的通路。

首先给出定义：

- **上游**指数据的来源方，**下游**反之。
- **inbound**指朝向**源服务器**的方向，**outbound**反之。

下面介绍了中间件的分类。

### 代理 proxy

代理是客户端选择使用的消息转发代理 *(agent)* ，
代理有的时候会做一些转换的操作（协议的转换等），
有的时候会进行简单的转发。

### 网关 也称反向代理 gateway a.k.a. reverse proxy

网关对于**outbound**的链接的客户端来说，是一个**源服务器**；
对于**inbound**，会将请求按照一定的规则转发到下游服务器。

通常网关会用来做一些负载均衡、安全检查、加速缓存等功能。

网关与**inbound**的服务器的交互协议是自由的。

### 隧道 tunnel

隧道是连接两个链接的信道，对于HTTP链接来说，隧道是透明的。

### 其他中间件

以上提到的三个中间件是会参与到HTTP协议中的，
还存在很多不参与HTTP协议的中间件，如运输层的中间件，
这些中间件也可以控制HTTP协议的流量。

这也提出了一个要求：**不能假定来自同一个链接的HTTP请求是同一个客户端发来的。**

## 2.4 缓存

**缓存**是对于之前的响应的本地存储，
子系统控制缓存的存储、获取和删除。

任何参与HTTP的组件都有可能 *(MAY)* 实现缓存机制。

一个响应如果是 **可缓存的** ，意味着可以被缓存来应答以后的请求。
更多的信息可以参考rfc7234。

## 2.5 一致性与异常处理

首先区分**生成**与**发送**：
**生成**表示产生一个新的协议元素 *(protocol element)* ，
**发送**表示简单的转发收到的报文到下游。

**一致性**的约定会按照参与HTTP的角色来定义。

**一致性**由协议元素的语法和语义两部分的规定组成。

> **协议元素**指的是HTTP报文中的一个组件。

1. 发送者MUST NOT生成一个自己认为是错误的协议元素。
1. 发送者MUST NOT生成一个不符合语法定义的协议元素。
1. 给定一个报文，发送者MUST NOT生成一个不能由自己的角色生成的协议元素。
1. 当接受一个协议元素并解析完成时，
接收者一定要能够解析所有长度合理、
内容符合接收者角色要求的、
语法正确的数据。
1. 关于长度

    考虑到根据不同的场景，协议元素的长度会在很大的范围内变动，
    **HTTP没有规定协议元素的长度**。
    最低限度，接收者需要能够解析它会生成的该类型协议元素的长度的协议元素。
    举个例子，如果一个源服务器会生成很长的URI来指明资源的位置，
    那么它需要支持解析来自其他请求的相同长度的URI。

1. 除非接收者（根据配置或历史等）判定接受到的协议元素相对本文档定义的语法是错误的，
它MUST按照本文档定义的语法来解释这个协议元素。

关于错误处理，接收者MAY尝试从一个错误的结构中恢复正确的协议元素。
HTTP没有专门的定义错误处理相关的内容，
因为不同的场景会有不同的错误处理策略。

# 参考

- [rfc7230](https://datatracker.ietf.org/doc/html/rfc7230)
