---
title: "rfc7230笔记"
date: 2021-07-22T14:55:02+08:00
draft: true
---

本文根据rfc文档的章节划分记录相关笔记。

<!--more-->

# 第一节 简介

HTTP协议是一种无状态的、应用层的、基于请求/响应构建的协议，
通过可扩展的语义的自描述的载荷来满足多变的基于网络的超文本信息系统的交互需求。

rfc7230是完整介绍HTTP/1.1的一系列文档的第一篇，
主要介绍了消息内容的语法和路由相关的内容。

HTTP协议是一个用于信息系统的通用性接口协议，
这意味着使用协议的双方不需要关心和了解对方的具体实现，
除此之外，HTTP协议的任意请求可以被看作是独立的，
这也是无状态性质的体现。

除了直接的连接客户端与服务端，
HTTP也被设计作为任意的其他协议的中间协议，
可以连接支持不同协议的信息系统。

因为这种多变性，所以协议无法详细的定义如何处理一个请求，
作为取代，
转而定义信息的语法、每次交流的目的、以及接收者被期望作出的响应。

稍为具体的，本文档介绍了协议会引用的结构，
定义了http、https和URI，
描述了总体的网络操作和链接管理，
以及定义了每个报文切分与转发的规则。

这些工作的目的是希望在独立于报文内容的情况下，
定义所有用于处理报文的必要的机制。
具体的，就是定义了处理报文和转发报文的所有要求。

# 2 Architecture 结构

## 2.1 客户端、服务端与报文

HTTP协议是一个无状态的请求响应协议，
通过交换报文来完成交互操作，
依赖底层的可靠传输链接。

HTTP的**客户端**指能够出于向服务端发送若干HTTP请求的目的而建立链接的程序；
**服务端**指能够接受链接来为HTTP请求提供服务，发送响应的程序。

**用户代理** *(User-Agent)* 指的是任意的能够发送请求的HTTP客户端程序。

**源服务器** *(Origin Server)* 指的是最源头、权威的能够服务该请求的资源的服务端程序。

HTTP依赖**统一资源描述符** *(Uniform Resource Identifier, URI)* 来指明请求的资源；
报文的格式类似于**Multipurpose Internet Mail Extensions, MIME**使用的格式。

## 2.2 实现的分歧

## 2.3 Intermediaries 中间件

协议允许使用若干中间件和链接来服务一个请求，
（因为**无状态**，）多个请求不要求也不保证经历相同的通路。

首先给出定义：

- **上游**指数据的来源方，**下游**反之。
- **inbound**指朝向**源服务器**的方向，**outbound**反之。

下面介绍了中间件的分类。

### 代理 proxy

代理是客户端选择使用的消息转发代理 *(agent)* ，
代理有的时候会做一些转换的操作（协议的转换等），
有的时候会进行简单的转发。

### 网关 也称反向代理 gateway a.k.a. reverse proxy

网关对于**outbound**的链接的客户端来说，是一个**源服务器**；
对于**inbound**，会将请求按照一定的规则转发到下游服务器。

通常网关会用来做一些负载均衡、安全检查、加速缓存等功能。

网关与**inbound**的服务器的交互协议是自由的。

### 隧道 tunnel

隧道是连接两个链接的信道，对于HTTP链接来说，隧道是透明的。

### 其他中间件

以上提到的三个中间件是会参与到HTTP协议中的，
还存在很多不参与HTTP协议的中间件，如运输层的中间件，
这些中间件也可以控制HTTP协议的流量。

这也提出了一个要求：**不能假定来自同一个链接的HTTP请求是同一个客户端发来的。**

## 2.4 缓存

**缓存**是对于之前的响应的本地存储，
子系统控制缓存的存储、获取和删除。

任何参与HTTP的组件都有可能 *(MAY)* 实现缓存机制。

一个响应如果是 **可缓存的** ，意味着可以被缓存来应答以后的请求。
更多的信息可以参考rfc7234。

## 2.5 一致性与异常处理

首先区分**生成**与**发送**：
**生成**表示产生一个新的协议元素 *(protocol element)* ，
**发送**表示简单的转发收到的报文到下游。

**一致性**的约定会按照参与HTTP的角色来定义。

**一致性**由协议元素的语法和语义两部分的规定组成。

> **协议元素**指的是HTTP报文中的一个组件。

1. 发送者MUST NOT生成一个自己认为是错误的协议元素。
1. 发送者MUST NOT生成一个不符合语法定义的协议元素。
1. 给定一个报文，发送者MUST NOT生成一个不能由自己的角色生成的协议元素。
1. 当接受一个协议元素并解析完成时，
接收者一定要能够解析所有长度合理、
内容符合接收者角色要求的、
语法正确的数据。
1. 关于长度

    考虑到根据不同的场景，协议元素的长度会在很大的范围内变动，
    **HTTP没有规定协议元素的长度**。
    最低限度，接收者需要能够解析它会生成的该类型协议元素的长度的协议元素。
    举个例子，如果一个源服务器会生成很长的URI来指明资源的位置，
    那么它需要支持解析来自其他请求的相同长度的URI。

1. 除非接收者（根据配置或历史等）判定接受到的协议元素相对本文档定义的语法是错误的，
它MUST按照本文档定义的语法来解释这个协议元素。

关于错误处理，接收者MAY尝试从一个错误的结构中恢复正确的协议元素。
HTTP没有专门的定义错误处理相关的内容，
因为不同的场景会有不同的错误处理策略。

## 2.6 协议版本

HTTP的版本，会在报文的第一行指出，
由`"<major>.<minor>"`形式构成。

在通讯中，版本号指明了报文发出者遵循的约定。

版本号中的**主版本号**表明了报文的语法，
**次版本号**指明了在该**主版本**中，
发送者支持了的最高**次版本**，
和在未来能够理解的最高**次版本**。

设计上，主版本号只会在加入了一个不兼容的语法定义时才会增加；
子版本号只会在增多了报文的语义或增加了发送者的能力时增加。

特别的，
对于HTTP/1.1，
设计上可以在去掉所有的新特性之后，
被HTTP/1.0的客户端或服务端解析。
（考虑这个因素，）HTTP/1.1有一些新特性会要求接受者的版本号，
换句话说，只有当发送者确定了接受者支持的版本号能够满足该特性的要求时，
才可以使用该特性。

当接受者接受到了一个主版本号可以支持，但有更高的次版本号的请求时，
SHOULD将其当作自身能够解析的最高的次版本号的请求来解析。
一个接受者可以假定一个由不清楚接受者是否支持该次版本号的发送者发送的更高次版本号的请求，
是可以向后兼容来支持由实现了任何相同主版本号的接受者来解析的。

### Header

对于**报文的头**部分，在一个主版本中，解析的方式不应改变，
但可以因为某些Header字段的缺失，作出不同的响应。
除非特别指出，HTTP/1.1的Header字段定义也是对于HTTP/1.x的定义。
特别的，不管HTTP/1.x是否与HTTP/1.1兼容，
`Host`和`Connection`字段应该被所有HTTP/1.x的具体实现支持。

如果一个Header字段语义上可以被接受者“无法识别 *(do not recognize them)* ”，
那么就可以在不修改协议版本的情况下增加。

### 中间件

处理报文的中间件，MUST用自己支持的HTTP版本号来转发信息，
这可以避免中间件与通信两端支持的版本号不一致时导致的错误。

### 客户端

客户端SHOULD使用自己能够支持的、主版本号不高于服务端支持的主版本号的最高版本。

客户端MUST NOT发送一个自己不支持的版本号。

当且仅当客户端发送过一个更高版本号的请求到服务端后，
（收到错误的响应，）确定服务端没有正确的实现该版本后，
MAY发送一个较低的版本的请求。

### 服务端

服务端SHOULD返回一个服务端支持的、主版本号小于等于接受到的请求中的主版本号的最大的版本号。

服务端MUST NOT返回一个不支持的版本号。

如果需要，
服务端可以返回505 *(HTTP Version Not Supported)* 错误来表明因为客户端的主版本号而拒绝服务。

当服务器确定或者怀疑客户端没有正确的实现协议，
并且不能解析后续的版本时，MAY发送一个HTTP/1.0的响应。
除非某些客户端发送的字段的值已知是错误的，这种协议降级SHOULD NOT被执行。

## 2.7 统一资源标识符 URI

URI在HTTP协议中用来指明资源，格式在RFC3986中定义。

### http的URI模式

> http-URI = "http:" "//" authority path-abempty [ "?" query ]
>            [ "#" fragment ]

- `authority` 表明了源服务器。
- `path-abempty`和可选的`query`部分指明了源服务器上的潜在资源。
- 可选的`fragment`部分独立于URI形式，可以用来非直接的指明次要的资源。

发送者MUST NOT生成一个没有host标识符的http URI；
接受者MUST以不合规拒绝这种请求。

`authority`决定了谁有权力来应答请求的资源。
这里提到了一个比较有意思的点，
类似域名这种registered names和IP地址，
因为存在层层委托的情况 *（比如DNS会将对更小的域名的搜索委托、授权到其他的DNS服务器）*，
所以其实它们构成了一个个命名空间。
至于响应请求的“权威”性，是由这些“委托”决定的，
这种过程称作 **名称委托过程** *(name delegation process)*，
这里也有一些安全性上的设计与考虑，在文档的第九节有讨论。

当htp URI用于访问一个指明的资源，
客户端MAY尝试解析host为IP地址，在目标IP地址和端口上建立TCP链接，
发送包含验证（？）信息的HTTP请求报文。
如果服务端使用非临时的 *(non-interim)* 、符合RFC7231第六节的响应来回应请求，
那么这个响应被认为是回应客户端的请求的权威的应答。

尽管协议是独立于传输层协议的，
但http的形式还是特定于基于TCP的服务。
这是因为前述的 **名称委托过程** 依赖于TCP建立其权威。
如果一个HTTP服务基于其他的底层协议，
那么它可能由不同于`http`的URI形式来标明，
比如`https`依赖于一个端到端的安全链接。

### https的URI模式

除了默认端口更换为443，https的模式需要满足http的要求。
另外，客户端MUST保证强加密、端到端的用于通讯的链接在第一个报文发送前就建立起来。

> https-URI = "https:" "//" authority path-abempty [ "?" query ]
>            [ "#" fragment ]

这里提到了一些同源的观点。
对于https和http两者，不能够因为两者的相同的域名相同的端口便共享“身份 *(identity)* ”。
它们被认为是不同的命名空间，
也被认为是不同的源服务器。
不过有一些HTTP的扩展协议，比如Cookie的协议RFC6265，
可以允许来自不同的服务器的信息在限定的范围内影响客户端与其他特定服务器的通信。

https的授权过程在RFC2818中定义。

### http与https的简化

- 默认端口可以省略
- 如果路径是空，可以省略

    `https://www.baidu.com/` -> `https://www.baidu.com`

- host部分是大小写不敏感的，其他部分是大小写敏感的。

# 参考

- [rfc7230](https://datatracker.ietf.org/doc/html/rfc7230)
