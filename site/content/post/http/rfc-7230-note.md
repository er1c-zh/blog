---
title: "rfc7230笔记"
date: 2021-07-22T14:55:02+08:00
draft: true
---

本文根据rfc文档的章节划分记录相关笔记。

<!--more-->

# 第一节 简介

HTTP协议是一种无状态的、应用层的、基于请求/响应构建的协议，
通过可扩展的语义的自描述的载荷来满足多变的基于网络的超文本信息系统的交互需求。

rfc7230是完整介绍HTTP/1.1的一系列文档的第一篇，
主要介绍了消息内容的语法和路由相关的内容。

HTTP协议是一个用于信息系统的通用性接口协议，
这意味着使用协议的双方不需要关心和了解对方的具体实现，
除此之外，HTTP协议的任意请求可以被看作是独立的，
这也是无状态性质的体现。

除了直接的连接客户端与服务端，
HTTP也被设计作为任意的其他协议的中间协议，
可以连接支持不同协议的信息系统。

因为这种多变性，所以协议无法详细的定义如何处理一个请求，
作为取代，
转而定义信息的语法、每次交流的目的、以及接收者被期望作出的响应。

稍为具体的，本文档介绍了协议会引用的结构，
定义了http、https和URI，
描述了总体的网络操作和链接管理，
以及定义了每个报文切分与转发的规则。

这些工作的目的是希望在独立于报文内容的情况下，
定义所有用于处理报文的必要的机制。
具体的，就是定义了处理报文和转发报文的所有要求。

# 2 Architecture 结构

## 2.1 客户端、服务端与报文

HTTP协议是一个无状态的请求响应协议，
通过交换报文来完成交互操作，
依赖底层的可靠传输链接。

HTTP的**客户端**指能够出于向服务端发送若干HTTP请求的目的而建立链接的程序；
**服务端**指能够接受链接来为HTTP请求提供服务，发送响应的程序。

**用户代理** *(User-Agent)* 指的是任意的能够发送请求的HTTP客户端程序。

**源服务器** *(Origin Server)* 指的是最源头、权威的能够服务该请求的资源的服务端程序。

HTTP依赖**统一资源描述符** *(Uniform Resource Identifier, URI)* 来指明请求的资源；
报文的格式类似于**Multipurpose Internet Mail Extensions, MIME**使用的格式。

## 2.2 实现的分歧

## 2.3 Intermediaries 中间件

协议允许使用若干中间件和链接来服务一个请求，
（因为**无状态**，）多个请求不要求也不保证经历相同的通路。

首先给出定义：

- **上游**指数据的来源方，**下游**反之。
- **inbound**指朝向**源服务器**的方向，**outbound**反之。

下面介绍了中间件的分类。

### 代理 proxy

代理是客户端选择使用的消息转发代理 *(agent)* ，
代理有的时候会做一些转换的操作（协议的转换等），
有的时候会进行简单的转发。

### 网关 也称反向代理 gateway a.k.a. reverse proxy

网关对于**outbound**的链接的客户端来说，是一个**源服务器**；
对于**inbound**，会将请求按照一定的规则转发到下游服务器。

通常网关会用来做一些负载均衡、安全检查、加速缓存等功能。

网关与**inbound**的服务器的交互协议是自由的。

### 隧道 tunnel

隧道是连接两个链接的信道，对于HTTP链接来说，隧道是透明的。

### 其他中间件

以上提到的三个中间件是会参与到HTTP协议中的，
还存在很多不参与HTTP协议的中间件，如运输层的中间件，
这些中间件也可以控制HTTP协议的流量。

这也提出了一个要求：**不能假定来自同一个链接的HTTP请求是同一个客户端发来的。**

## 2.4 缓存

**缓存**是对于之前的响应的本地存储，
子系统控制缓存的存储、获取和删除。

任何参与HTTP的组件都有可能 *(MAY)* 实现缓存机制。

一个响应如果是 **可缓存的** ，意味着可以被缓存来应答以后的请求。
更多的信息可以参考rfc7234。

## 2.5 一致性与异常处理

首先区分**生成**与**发送**：
**生成**表示产生一个新的协议元素 *(protocol element)* ，
**发送**表示简单的转发收到的报文到下游。

**一致性**的约定会按照参与HTTP的角色来定义。

**一致性**由协议元素的语法和语义两部分的规定组成。

> **协议元素**指的是HTTP报文中的一个组件。

1. 发送者MUST NOT生成一个自己认为是错误的协议元素。
1. 发送者MUST NOT生成一个不符合语法定义的协议元素。
1. 给定一个报文，发送者MUST NOT生成一个不能由自己的角色生成的协议元素。
1. 当接受一个协议元素并解析完成时，
接收者一定要能够解析所有长度合理、
内容符合接收者角色要求的、
语法正确的数据。
1. 关于长度

    考虑到根据不同的场景，协议元素的长度会在很大的范围内变动，
    **HTTP没有规定协议元素的长度**。
    最低限度，接收者需要能够解析它会生成的该类型协议元素的长度的协议元素。
    举个例子，如果一个源服务器会生成很长的URI来指明资源的位置，
    那么它需要支持解析来自其他请求的相同长度的URI。

1. 除非接收者（根据配置或历史等）判定接受到的协议元素相对本文档定义的语法是错误的，
它MUST按照本文档定义的语法来解释这个协议元素。

关于错误处理，接收者MAY尝试从一个错误的结构中恢复正确的协议元素。
HTTP没有专门的定义错误处理相关的内容，
因为不同的场景会有不同的错误处理策略。

## 2.6 协议版本

HTTP的版本，会在报文的第一行指出，
由`"<major>.<minor>"`形式构成。

在通讯中，版本号指明了报文发出者遵循的约定。

版本号中的**主版本号**表明了报文的语法，
**次版本号**指明了在该**主版本**中，
发送者支持了的最高**次版本**，
和在未来能够理解的最高**次版本**。

设计上，主版本号只会在加入了一个不兼容的语法定义时才会增加；
子版本号只会在增多了报文的语义或增加了发送者的能力时增加。

特别的，
对于HTTP/1.1，
设计上可以在去掉所有的新特性之后，
被HTTP/1.0的客户端或服务端解析。
（考虑这个因素，）HTTP/1.1有一些新特性会要求接受者的版本号，
换句话说，只有当发送者确定了接受者支持的版本号能够满足该特性的要求时，
才可以使用该特性。

当接受者接受到了一个主版本号可以支持，但有更高的次版本号的请求时，
SHOULD将其当作自身能够解析的最高的次版本号的请求来解析。
一个接受者可以假定一个由不清楚接受者是否支持该次版本号的发送者发送的更高次版本号的请求，
是可以向后兼容来支持由实现了任何相同主版本号的接受者来解析的。

### Header

对于**报文的头**部分，在一个主版本中，解析的方式不应改变，
但可以因为某些Header字段的缺失，作出不同的响应。
除非特别指出，HTTP/1.1的Header字段定义也是对于HTTP/1.x的定义。
特别的，不管HTTP/1.x是否与HTTP/1.1兼容，
`Host`和`Connection`字段应该被所有HTTP/1.x的具体实现支持。

如果一个Header字段语义上可以被接受者“无法识别 *(do not recognize them)* ”，
那么就可以在不修改协议版本的情况下增加。

### 中间件

处理报文的中间件，MUST用自己支持的HTTP版本号来转发信息，
这可以避免中间件与通信两端支持的版本号不一致时导致的错误。

### 客户端

客户端SHOULD使用自己能够支持的、主版本号不高于服务端支持的主版本号的最高版本。

客户端MUST NOT发送一个自己不支持的版本号。

当且仅当客户端发送过一个更高版本号的请求到服务端后，
（收到错误的响应，）确定服务端没有正确的实现该版本后，
MAY发送一个较低的版本的请求。

### 服务端

服务端SHOULD返回一个服务端支持的、主版本号小于等于接受到的请求中的主版本号的最大的版本号。

服务端MUST NOT返回一个不支持的版本号。

如果需要，
服务端可以返回505 *(HTTP Version Not Supported)* 错误来表明因为客户端的主版本号而拒绝服务。

当服务器确定或者怀疑客户端没有正确的实现协议，
并且不能解析后续的版本时，MAY发送一个HTTP/1.0的响应。
除非某些客户端发送的字段的值已知是错误的，这种协议降级SHOULD NOT被执行。

## 2.7 统一资源标识符 URI

URI在HTTP协议中用来指明资源，格式在RFC3986中定义。

### http的URI模式

> http-URI = "http:" "//" authority path-abempty [ "?" query ]
>            [ "#" fragment ]

- `authority` 表明了源服务器。
- `path-abempty`和可选的`query`部分指明了源服务器上的潜在资源。
- 可选的`fragment`部分独立于URI形式，可以用来非直接的指明次要的资源。

发送者MUST NOT生成一个没有host标识符的http URI；
接受者MUST以不合规拒绝这种请求。

`authority`决定了谁有权力来应答请求的资源。
这里提到了一个比较有意思的点，
类似域名这种registered names和IP地址，
因为存在层层委托的情况 *（比如DNS会将对更小的域名的搜索委托、授权到其他的DNS服务器）*，
所以其实它们构成了一个个命名空间。
至于响应请求的“权威”性，是由这些“委托”决定的，
这种过程称作 **名称委托过程** *(name delegation process)*，
这里也有一些安全性上的设计与考虑，在文档的第九节有讨论。

当htp URI用于访问一个指明的资源，
客户端MAY尝试解析host为IP地址，在目标IP地址和端口上建立TCP链接，
发送包含验证（？）信息的HTTP请求报文。
如果服务端使用非临时的 *(non-interim)* 、符合RFC7231第六节的响应来回应请求，
那么这个响应被认为是回应客户端的请求的权威的应答。

尽管协议是独立于传输层协议的，
但http的形式还是特定于基于TCP的服务。
这是因为前述的 **名称委托过程** 依赖于TCP建立其权威。
如果一个HTTP服务基于其他的底层协议，
那么它可能由不同于`http`的URI形式来标明，
比如`https`依赖于一个端到端的安全链接。

### https的URI模式

除了默认端口更换为443，https的模式需要满足http的要求。
另外，客户端MUST保证强加密、端到端的用于通讯的链接在第一个报文发送前就建立起来。

> https-URI = "https:" "//" authority path-abempty [ "?" query ]
>            [ "#" fragment ]

这里提到了一些同源的观点。
对于https和http两者，不能够因为两者的相同的域名相同的端口便共享“身份 *(identity)* ”。
它们被认为是不同的命名空间，
也被认为是不同的源服务器。
不过有一些HTTP的扩展协议，比如Cookie的协议RFC6265，
可以允许来自不同的服务器的信息在限定的范围内影响客户端与其他特定服务器的通信。

https的授权过程在RFC2818中定义。

### http与https的简化

- 默认端口可以省略
- 如果路径是空，可以省略

    `https://www.baidu.com/` -> `https://www.baidu.com`

- host部分是大小写不敏感的，其他部分是大小写敏感的。

# 3 报文格式

HTTP报文由一个**起始行** *(start line)* 开始，
后续是类似于**因特网报文格式** *(Internet Message Format, RFC5322)* 的字符序列。
字符序列包含：

1. 首先是零个或多个**首部字段**，合并称为**首部** *(headers or header section)*。
1. 一个空行表示**首部**的结束。
1. 最后是可选的报文体。

> HTTP-message   = start-line
>                  *( header-field CRLF )
>                  CRLF
>                  [ message-body ]

通常解析报文的流程是：

1. 读取**起始行**。
1. 一次读取**首部字段**，根据**字段名称**写入到一个哈希表中，直到遇到空行。
1. 根据**首部**的信息，判断是否需要存在报文体。
如果存在，那么将报文体作为一个流读入，直到读取了足够多的字符或链接被关闭为止。

由于解析多字节字符的库面对不合法的、包含换行符的序列时的不确定性，
如果将HTTP报文作为一个Unicode字符流来处理，会导致安全问题。
因此，接受者MUST将HTTP报文作为一个使用了US-ASCII超集的编码的字节流来处理。
当拆分报文完成后，便可使用基于字符串的解析器 *(string-based parser)* 。

发送者MUST NOT在**起始行**和第一个**首部字段**之间写入空白字符；
接受者在收到这种请求时，MUST因不合法而拒绝这个请求，
或直接丢弃掉所有空白字符之前的行。
这种情况可能是攻击者希望服务器忽略一些字段或将后续的数据当作一个新的请求来处理，
这些都有可能导致安全上的问题。

## 3.1 起始行 Start Line

语法上，请求与响应报文的区别仅在于它们的开始行，一个称为**请求行** *(request-line)* ，
另一个称为**状态行** *(status-line)* 。

> start-line     = request-line / status-line

### 3.1.1 请求行

请求行的构成：

> request-line   = method SP request-target SP HTTP-version CRLF

- `method`表明要对资源执行的操作，大小写敏感。
- `request-target`表明目标资源。

接受者通常可以使用空白字符切分请求行，因为空白字符不应该也不允许出现在这三个部分中。
但一些客户端没有正确的实现，导致`request-target`中可能存在空白字符。
对于这种不合法的请求行，接受者SHOULD返回400 *(Bad Request)* 错误，
或者一个指向正确的`request-target`的301 *(Moved Permanently)* 响应。
接受者SHOULD NOT不重定向而自动修正`request-target`并处理请求，
因为这可能导致安全问题。

协议没有预定请求行的长度限制，
如果服务器接收到了过长的`method`，那么SHOULD返回501 *(Not Implemented)* 响应；
如果接收到了过长的`request-target`，应该MUST返回414 *(URI Too Long)* 错误。

RECOMMENDED，所有的HTTP协议的发送者和接受者，请求行最少支持8000字符长度。

### 3.1.2 状态行

状态行的构成：

> status-line = HTTP-version SP status-code SP reason-phrase CRLF

- `status-code`是一个三位数字，用来描述服务端处理客户端请求的结果。
更详细的介绍在RFC7231第六节。
- `reason-phrase`用于解释`status-code`。

## 3.2 首部字段

每个首部字段由：
1. 大小写无关的字段名称
1. 紧随其后的冒号
1. 可选的空白字符
1. 字段的值
1. 可选的空白字符

字段名称指明了字段值的语义。

### 3.2.1 字段的扩展性

首部的字段可以任意的扩展。

新的首部字段可以被定义为覆盖之前定义的字段的语义。

**代理** *(Proxy)* MUST转发自己不能识别的首部字段，
除非这个字段是列出的**链接首部字段** *(Connection header field, Section 6.1)，
或者该**代理**被设置为过滤或转换这种字段。
其他的接受者SHOULD忽略未识别的首部字段。
这些要求能够允许HTTP协议在不要求已经部署的中间件生气的情况下，改进新功能。

### 3.2.2 字段顺序

对于不同的首部字段名的字段来说，
首部中字段的顺序是不重要的。

首先发送包含“控制”信息的数据是好的实践，
比如请求报文的`Host`和响应报文的`Date`，
这样可以尽快的让接受者决定是否处理该请求。

服务端MUST NOT在接受到全部的请求报文的首部之前，
实际的处理请求。
这是因为后续的首部字段可能会包含影响处理请求的条件、权限或者有意误导的重复首部字段。

发送者MUST NOT生成多个首部字段名相同的首部字段，
除非：

- 该字段的值被定义为逗号分割的列表
- 该字段是一个众所周知的特殊字段

    特别的，`Set-Cookie`在响应中存在多次，且没有实现为列表语义，
    所以需要特别的处理。

接受者MAY将多个相同首部字段名的首部字段通过逗号、按顺序连接起来。
因此，代理MUST NOT在转发报文的时候修改字段的值的顺序。

### 3.2.3 空白字符

协议的空白字符分为三类：

- 可选 OWS (optional whitespace)

    可选的空白字符主要用于增强可读性。

- 必须 RWS (required whitespace)

    必须的空白字符用于分割字段的token。

- 坏的空白字符 BWS (bad whitespace)

    除历史原因之外，不能使用的空白字符。

### 3.2.4 首部字段的解析

当接受到报文时，首先会使用通用的算法来解析，
这个阶段会忽略首部字段内容的格式。

出于安全考虑，首部字段名与冒号之间不允许存在空白字符。
服务端MUST用400 *(Bad Request)* 拒绝这种请求。
代理MUST在转发报文到下游之前，移除响应报文中的这种空白字符。

首部字段值只获取\[第一个非空白字符, 最后一个非空白字符\]作为值。

历史上，HTTP允许使用ISO-8859-1字符集，
但实现上，通常只使用ASCII的子集。
因此，新定义的首部字段SHOULD限制字段值只使用ASCII字符。
接受者SHOULD将ASCII之外的字符作为**不透明数据** *(opaque data)* 来对待。

### 3.2.5 字段的各种限制

和协议开始的约定一致，没有在协议中定义首部字段的长度限制。

服务器如果收到了一个超过自己支持的首部字段长度的请求，
MUST返回一个4xx (Client Error) 错误。
否则，会增加 **夹带请求攻击** *(request smuggling attack)* 的风险。

如果语义上允许，客户端MAY丢弃或者截断超过支持的首部字段。

### 3.2.6 字段值的构成部分

绝大多数的首部字段值格式是用通用语法组件 *(common syntax component)* 和各种**定界字符** *(delimiting character)* 定义的。
对于定界字符，是从不能在`token`中出现的ASCII可见字符中选择的。

双引号包裹的字符串会被作为整体解析为一个单独的值。

反斜杠可以作为双引号包裹住的字符串或注释结构中的转义机制。

## 3.3 报文体

报文体承载了请求或响应的负载。
除非指定了**传输编码** *(transfer coding)* ，
报文体的内容与载荷的内容应该是完全一致的。

指明是否存在报文体的规则在请求和响应中是不同的：

- 对于请求来说，需要在首部中存在`Content-Length` **或** `Transfer-Encoding`字段。

- **对于响应来说，是否存在报文体由请求方法和状态码来决定，**
有如下的特殊情况，没有报文体（，除此之外，都存在长度大于等于0的报文体）：

    - 对于`HEAD`方法的请求，都没有报文体。
    - 对去`CONNECT`请求，2xx状态码表示切换到隧道模式，没有报文体。
    - 所有的 1xx (Informational) 204 (No Content) 304 (Not Modified) 的响应都表明没有报文体。

另外，请求报文的结构与请求方法无关，尽管请求方法没有定义报文体的用途（也可以有报文体）。

### 3.3.1 传输编码 Transfer-Encoding

`Transfer-Encoding`首部字段表明了应用到了载荷的编码格式的列表。

例子：

> Transfer-Encoding: gzip, chunked

表示先经过gzip的压缩，然后进行了分片。

在HTTP中，`Transfer-Encoding`有两个主要目的：

- 精确的切分动态生成的载荷
- 区分应用编码为了提高传输效率或安全性还是为了体现所选资源自身的特征

接受者MUST能够解析`chunked`类型的传输编码，
因为这是分片传输未知大小载荷的报文时重要的一环。
发送者MUST NOT对同一报文体重复分块。
如果应用了除`chunked`之外的其他编码，
`chunked`编码一定要在最后应用来保证正确的分片。

区分于`Content-Encoding`是表现 *(representation)* 的性质，
`Transfer-Encoding`是报文的性质。
对于一个请求和响应，
从产生到到达的整个链路中的任意组件，
都可能去按照`Transfer-Encoding`解码内容来减少一层编码
或增加一层编码。

服务端MUST NOT在1xx *(Informational)* 或204 *(No Content)* 
的响应中返回`Transfer-Encoding`首部字段。
服务端MUST NOT在返回对应一个`CONNECT`请求的2xx *(Successful)* 
响应时包含`Transfer-Encoding`首部字段。

`Transfer-Encoding`是HTTP/1.1新加入的字段，
所以客户端MUST NOT在不确定服务端是否支持HTTP/1.1的情况下，
发送包含`Transfer-Encoding`的请求。
同样地，除非能从请求中确定发送者支持HTTP/1.1，
服务端MUST NOT使用`Transfer-Encoding`字段。

当服务端接受到不支持的`Transfer-Encoding`（编码格式）时，
SHOULD返回一个501 *(Not Implemented)* 错误。

### 3.3.2 Content-Length

`Content-Length`在没有`Transfer-Encoding`时，
提供了潜在的载荷内容长度（字符的个数）。
如果报文拥有载荷，
那么`Content-Length`帮助分片传输来确定报文体的结尾；
如果报文没有载荷，
`Content-Length`表明了被选中的**表现** *（representation 会在第三节介绍）* 的大小。

发送者MUST NOT发送既有`Content-Length`也有`Transfer-Encoding`的报文。

如果请求报文没有包含`Transfer-Encoding`，且请求方法需要一个封闭 *(enclosed)* 的载荷，
那么用户代理SHOULD在报文中包含`Content-Length`字段。
如果请求报文不包含载荷且请求方法也没有需要有载荷，
那么用户代理SHOULD NOT设置`Content-Length`字段。

对于HEAD请求的响应或304响应，
MAY返回目标资源的200响应时的`Content-Length`。

对于1xx和204响应，
服务端MUST NOT设置`Content-Length`字段。
对于CONNECT请求的响应，
服务端MUST NOT设置`Content-Length`字段。

除了一些特殊的情况，
当没有设定`Transfer-Encoding`时，
源服务器如果知道载荷的大小，
SHOULD设置`Content-Length`帮助下游接受者处理报文。

协议没有规定`Content-Length`的大小，处理时需要小心溢出的问题。

有时报文会存在多个`Content-Length`字段或字段的值是一个列表，
这种情况是由于上游存在处理的问题导致的，
接受者应该拒绝或修复这个问题。

### 3.3.3 报文体的长度

报文体的长度由以下规则决定，有优先级：

1. 对于HEAD请求的响应和状态码为1xx、204、304的响应，
报文的解析在遇到第一个空行时结束，因为这些响应没有也不能 *(cannot contain)* 报文体。
1. 对于CONNECT请求、状态码为2xx的响应，
（因为在解析完该响应报文的首部之后，会立即成为一个隧道，所以）
客户端MUST忽略首部的`Transfer-Encoding`和`Content-Length`字段。
1. 如果报文采用了`chunked`编码且是`Transfer-Encoding`的最后一个编码，报文体的结束由报文体的内容决定。
如果响应报文应用了`chunked`编码但不是最终的编码，
当链接被关闭时，报文数据传输结束。
如果是请求报文存在这种情况，没有可靠的途径来决定什么时候报文传输完毕，
服务端MUST返回一个400错误，然后关闭链接。
如果一个报文同时包含`Transfer-Encoding`和`Content-Length`字段，
`Transfer-Encoding`字段生效。
1. 如果报文中只包含`Content-Length`字段，
且存在多个不同的`Content-Length`值或非法的`Content-Length`值，
那么这个报文是一个非法的报文，接受者根据自己的角色和请求、响应来进行错误处理：

    - 对于请求报文，MUST返回400错误
    - 对于响应报文，如果是代理，那么代理MUST关闭于服务端的链接，丢弃这个响应，返回502错误；
    如果是客户端，MUST关闭与服务器的代理，并丢弃这个响应。

1. 如果有一个合法的`Content-Length`值且没有`Transfer-Encoding`时，
那么`Content-Length`的值表明了期望传输的按字符计算的载荷长度。
如果在接受到目标长度的报文之前断开了链接或超时，
那么MUST丢弃这些数据，并关闭链接。

1. 如果没有上述的情况（，即没有`Content-Length`也没有`Transfer-Encoding`），
且该报文是一个请求报文，那么表明报文的长度是0；
如果是响应报文，服务端关闭链接表明数据传输完成。

特别的，并无可靠的方法来区分关闭链接是表明传输完成或者网络问题导致的关闭，
所以服务端SHOULD在可能的情况下生成`Transfer-Encoding`或`Content-Length`字段。
关闭链接表明报文传输完成是为了兼容HTTP/1.0。

服务端MAY通过返回411 (Length Required) 错误来处理有消息体但缺乏`Content-Length`字段的请求。

除非是应用了除了`chunked`之外的传输编码，
客户端在知道报文体长度的情况下，SHOULD发送带有`Content-Length`的请求。
这是因为存在一些服务端实现，
会对于缺少`Content-Length`的`chunked`请求，会返回411 (Length Required) 错误。

如果用户代理不确定服务端是否能够处理HTTP/1.1请求，
MUST发送带有合法`Content-Length`字段的请求。

如果客户端发现有超出`Content-Length`的数据，
MUST NOT处理、缓存或者转发。

## 3.4 处理不完整的报文

对于服务器来说，一个不完整的报文通常意味着超时等问题的发生，
MAY发送一个标识错误的响应，然后关闭链接。

当一个链接过早的关闭或解析分块的请求失败时，
客户端接受到不完整的报文，
MUST标记报文为*不完整*的。

## 3.5 解析报文的鲁棒性

# 4 传输编码 *Transfer Codings*

传输编码用来实现载荷体在网络中 **“安全传输”**。

传输编码是报文的性质，区别于载荷中数据的表现格式的性质。

传输编码的名称是大小写敏感且在HTTP Transfer Coding registry注册的。

## 4.1 分块传输编码 *Chunked Transfer Coding*

**分块传输编码** 用于将载荷转换为一系列数据块。

整个数据块序列由若干普通块（`chunk`）、
最终块（`last-chunk`）、
可选的尾部部分（`trailer-part`）和表示结束的空行构成。

普通块开头是表示该块大小的`chunk-size`，
随后可能存在表示附加信息的`chunk-ext`，
换行之后就是该块承载的数据`chunk-data`。

### 4.1.1 附加信息 `chunk-ext`

每个块在块大小之后都可能有任何数量的附加信息，
用来表示：

- 每个块的元数据，如摘要或哈希
- mid-message control information
- randomization of message body size

### 4.1.2 分块的追加部分 *Chunked Trailer Part*

**追加部分**给分块消息的发送者提供了发送在发送分块信息的过程中生成的数据的能力。

格式上，追加部分由若干字段构成；
除了所处的位置不同，追加部分的字段与首部字段完全一致。

当接受者接受到了非空的追加部分数据时，
MAY按照“将这些字段放置在报文首部的最后”来处理。

出于安全考虑，接受者MUST忽略不允许出现在**追加部分**中的首部字段。

除非必要情况或客户端暗示**追加部分**是可接受的，
服务端SHOULD NOT生成**追加部分**。
如果客户端没有明确声明支持，
**追加部分**可能会被链路上的环节静默丢弃。
这允许中间件将分块的报文，在没有缓冲整个响应时，转换为非分块的报文。

### 4.1.3 解码分块

解码被分块的报文：

1. 一个循环，直到所有的块被读取完毕。

    读取该块的大小`chunk-size`。
    根据大小读取数据放到缓冲区中，
    增加数据的总长度。

1. 尝试读取追加部分。

    如果存在，将追加部分中的字段追加到已有的首部字段后。

1. 设置`Content-Length`为数据的总长度。

1. 从`Transfer-Encoding`移除`chunked`标记。

## 4.2 压缩编码

用来压缩载荷。

### 4.2.1 Compress Coding

一种兼容LZW *(Lempel-Ziv-Welch)* 的压缩编码。

### 4.2.2 Deflate Coding

一种压缩编码。

### 4.2.3 Gzip Coding

一种压缩编码。

## 4.3 TE

**TE** 首部字段在请求中表示客户端期望的传输编码，
和是否希望在分块编码传输中接受追加字段。
字段的内容为逗号分割的编码名称和关键字`trailers`。

## 4.4 Trailer

对于有追加字段的响应，
发送者SHOULD在首部字段中增加**Trailer**字段，
表明追加字段中有哪些字段。

这项信息可以帮助接受者在解析报文时进行需要的工作。

# 5 报文路由 Message Routing

HTTP请求报文的路由选择由客户端决定，
如下信息会影响这个决定：

- 目标资源
- 客户端的代理配置
- 建立新的链接或复用inbound链接

对应该请求的响应报文的路由会按照请求的链路原路返回。

## 5.1 区分出目标资源

HTTP链接由用户代理按照若干目的来初始化。
目的是请求语义和需要执行语义的目标资源的组合。

URI是一种区分目标资源的标识符。

## 5.2 建立到服务器的链接

根据URI定位到目标资源后，
客户端需要判断是否需要一个网络请求来完成语义，
以及该请求需要发送到哪里。

如果存在能满足目的的缓存，通常，请求会被发送到缓存。

否则，客户端会检查是否有代理能够满足这个请求。
如果有的话，会建立或复用到代理的链接。

最后，其他方式都无法满足，
客户端会根据协议（比如HTTP或HTTPS）尝试直接连接到目标资源。

## 5.3 请求目标 Request Target

当到服务器的链接建立完成之后，
客户端发送一个包含了`request-target`的HTTP请求报文。

`request-target`根据请求的方法和请求是否通过代理有四种不同的格式：

```plain
request-target = origin-form
    / absolute-form
    / authority-form
    / asterisk-form
```

### 5.3.1 origin-form

```origin-form    = absolute-path [ "?" query ]```

`origin-form`是最常用的`request-target`格式。
当客户端直接向目标服务器发送请求时，
除了CONNECT请求或server-wide OPTIONS请求，
MUST发送URI的绝对路径和query部分作为`request-target`，
也就是`origin-form`格式。

### 5.3.2 absolute-form

用于向proxy发送的请求。

```absolute-form  = absolute-URI```

但是这里有个问题，缺少query如何正确的查询？

### 5.3.3 authority-form

用于CONNECT请求。

```authority-form = authority```

### 5.3.4 asterisk-form

用于server-wide OPTIONS请求。

```asterisk-form  = "*"```

当客户端希望向整个服务端的资源发送OPTIONS请求时，
会使用asterisk-form作为`request-target`。

# 参考

- [rfc7230](https://datatracker.ietf.org/doc/html/rfc7230)
