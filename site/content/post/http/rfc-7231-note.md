---
title: "RFC7231笔记"
date: 2021-09-21T23:06:56+08:00
draft: true
tags:
    - http
    - rfc
    - memo
    - http-1_1-rfc
---

本文根据RFC文档的章节划分记录相关笔记，
是HTTP/1.1定义的的第二篇，
内容主题是语义 *(semantics)* 和内容 *(content)* 。

<!--more-->

{{% serial_index http-1_1-rfc %}}

# 1 简介

所有的HTTP报文要么是请求报文要么是响应报文。
服务端在链接上等待请求，
解析接受到的报文，
解释报文的语义，
生成一个或多个响应报文来响应请求。
客户端构建请求报文提出自己的期望，
检测收到的响应是否满足需要，
决定如何解释结果。

HTTP提供了与资源交互的统一的接口，
与类型、性质和实现无关。

HTTP语义由请求方法来定义意图，
可能由首部字段来扩充语义，
状态码表明机器友好的的响应结果，
响应的首部字段可能会包含其他的控制数据或资源元数据。

# 2 资源

HTTP请求的目标被称作资源。
协议不规定资源的属性，
仅仅定义与资源交互的接口。
资源由URI区分。

客户端发送请求时，
会将标识目标资源的URI按照RFC7230中的一个形式传入。
服务端接收到请求时，
重建有效的URI。

一个HTTP的设计目标的是将资源描述符与请求的语义解耦，
这通过请求方法和一些首部字段来实现。
如果请求方法与URI定义的语义冲突，
请求方法的语言更加优先。

# 3 表现 Representations

考虑到资源可以是任何形式的，
和HTTP协议提供的接口像是定义了可以观察可操作资源的窗户，
我们需要定义一个抽象的概念来描述资源的当前状态或需要（变成）的状态。
这个抽象就是表现。

根据HTTP协议的目标，
表现是一种信息，
满足：

- 能反应资源的过去、现在或需要的状态
- 格式可以容易的通过HTTP来传输
- 包含元数据和需要表现的数据

服务器有可能需要支持接受多种表现
或生成多种表现，
这个时候就需要服务器通过一些算法
选出最适合请求的表现，
这通常由内容协商机制来完成。
选中的表现用来为evaluating conditional requests提供数据和元数据，
和为GET请求的200或304响应构建载荷。

## 3.1 表现元数据

表现首部字段提供表现需要的元数据。
当报文包含载荷体时，
表现首部字段指明如何解析报文的载荷体中的表现数据。
对于HEAD请求的响应报文来说，
表现首部字段指明如何解析只有方法改为GET的请求的响应报文的载荷体中的表现数据。

### 3.1.1 处理表现数据

#### 3.1.1.1 Media Type

HTTP协议使用Internet media types在
`Content-Type`字段和`Accept`字段中
实现开放和可扩展的数据类型和类型协商机制。
Media type定义了数据格式和多种处理数据的模型。

Media Type形如`type "/" subtype *( OWS ";" OWS parameter )`，
type、subtype和parameter的name大小写不敏感。
parameter的value是否大小写敏感取决于parameter的语义。

parameter的value是否有引号没有关系。

#### 3.1.1.2 Charset

`Charset`用于协商文本类型的表现的字符编码格式。

`Charset`的值大小写不敏感。

#### 3.1.1.3 规范化与文本默认（格式？）

Internet media type在IANA注册时会有一个规范化的格式，
为了在多种编码格式的系统中迁移。
由于许多与与MIME相同的原因，
HTTP使用规范化的格式来传输表现。

与MIME不同的，
HTTP允许文本类型的media使用CR或LF或CRLF作为换行符。

#### 3.1.1.4 Multipart Types

MIME提供了数种“多部分”的类型，
将多个表现封装到同一个报文体中。
所有的多部分类型拥有同样的语法，
media type中有`boundary`参数 *（parameter）* 。

发送者使用CRLF作为消息体多个部分的之间的换行。

HTTP报文不使用`boundary`参数作为消息体长度。

# 参考

- [rfc7231](https://datatracker.ietf.org/doc/html/rfc7231)
