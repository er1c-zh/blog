---
title: "CRDT简单原理"
date: 2021-04-05T10:59:43+08:00
draft: false
tags:
    - distributed
    - data_struct
    - what
---

CRDT *(Conflict-free Replicated Data Types)* 是一种数据结构，能够在AP的情况下，提供数据的最终一致性。

对于CRDT有两种等价的描述，分别是基于状态描述(state-based)和基于操作描述(operation-based)。

# 概念与定义

- 表示集群的集合与正确的

    定义一个有限集合，其中的元素为无拜占庭问题的进程。
    其中的进程会：
    
    1. 随机、无预警的崩溃(crash)
    1. 永久的崩溃
    1. 保留所有状态恢复

    对于没有崩溃的元素称为 **正确的** (correct)。

# 基于状态描述的对象 state-based object

设想我们维护一个对象，
在集群上，每个进程有一个这个对象的副本。
具体的，对象是一个元组 $(S,s^0,q,u,m)$ 。

每个进程 $p\_i$ 有自己的对象，和自己的状态 $s\_i \in S$，
其中 $s\_i$ 被称为 **载荷** (payload)。
**载荷** 的初始值是 $s^0$ 。

$q$ $u$ $m$ 是对象的**方法** (method)，
对象的用户会用 query $q$ 来查询状态，
用 update $u$ 来更新状态，
merge $m$ 用来合并两个副本。
方法都是在单个副本上执行的。

系统运行时，会通过容错的方法将所有副本上的所有更新投递给所有的副本，
一个副本在接收到其他副本的更新消息时，
通过 $merge$ 来合并。

## 一些定义和解释

- 一个方法的所有前提被满足的状态被称为 **启用的** (enable)。一个启用的方法会在被调用时尽快执行。

- 方法的排序
    - 定义 $f^k\_i(a)$ 是在副本 $i$ 上执行的第 $k$ 个方法，排序从1开始。
    - 定义 $K\_i(f)$ 是方法 $f$ 在副本 $i$ 上执行的序号。

    有 $K_i(f^k_i(a)) = k$ 成立。

- 状态的变更
    - 定义 $s^k\_i$ 是副本 $i$ 在第$k$个方法执行完成后的状态，特别的 $s^0\_i=s^0$。

    我们将第$k$个方法在副本$i$上的执行和状态的变化表示为：
    
    $$
    s^{k-1}_i \cdot f^k_i(a) = s^k_i
    $$
- 如果两个状态对于任何查询方法调用返回相同的结果，那么称这两个状态为**相等**(equivalence)。

## 因果关系史 (Casual History) 与网络通信

对于一个对象（指全系统所有副本的聚合体），有自己的**因果关系史**。
定义**因果关系史**为一个集合：

$$
C = [c\_1,...,c\_n]
$$

其中，$c\_i$ 是一个序列，表示节点$i$的因果关系史，
从$c^0\_i$依次转化为$c^k\_i$。

对于三种操作，变化如下：

- 查询$q$对因果关系史不产生影响，即如果第$k$操作是查询操作，则$c^{k-1}\_i = c^k\_i$成立。
- 更新$u$将更新的结果并入因果关系史，对于$u^k\_i(a)$，有$c^k\_i=c^{k-1}\_i \cup \{ {u^k\_i(a)} \}$成立。
- 合并$m$将两个因果关系史合并，对于 $m^k\_i(s^{k^{\prime}}\_{i^{\prime}})$，
        有$c^k\_i=c^{k-1}\_{i-1} \cup c^{k^{\prime}}\_{i^{\prime}}$成立。

- 如果一个更新已经被包括在因果关系史中，那么称为**已投递**(delivered)。
- 对于更新$u$和更新$u'$，如果当$u'$执行的时候，如果$u$已经在因果关系史中，
    那么称$u$ **先行发生** (happen-before)于$u'$。
- 两个更新如果互相不先行发生于对方，那么称这两个更新是**并行的**(concurrent)。

基于“容错的网络”，我们可以推定，每一个更新最终都会被每一个副本得知。
但是不能保证所有副本会汇聚到同一个状态。

为了解决这个问题，我们先给出**强最终一致性**的定义。

## **强最终一致性** (Strong Eventual Consistency)

首先给出**最终一致性**的定义：

- **最终投递** (Eventual Consistency) 任何一个投递到**正确的**副本的更新，最后都会被投递到所有的**正确的**副本上。
- **汇聚性** (Converagence) 对于任意两个**正确的**副本，如果有相同的更新集合被投递，最后两者会达到**相等的**状态。
- **终止性** (Termination) 所有的**方法**会执行终止。

如果有一个更新被并行的执行在**最终一致性**的两个副本上，
通常每个副本会立即执行更新，
随后通过其他手段发现冲突并解决。

为了（在满足**汇聚性**的条件下）解决这种冲突，需要让多个副本之间达成一个共识，这是一个十分消耗资源的操作。

为了解决这种情况，我们增加了一个条件来构成**强最终一致性**：

- **强汇聚性** 对于投递了相同更新的两个**正确的**副本，会达到**相等的**状态。

# 基于状态的、最终汇聚、多副本的数据类型 (State-based Convergent Replicated Data Type) CvRDT

在介绍了 **强最终一致性** 之后，
接下来给出 **基于状态的对象** 满足 **强汇聚性** 的充分条件。

对于一个基于状态的对象，
如果是一个 **单调半格对象** ，
那么它就满足 **强汇聚性** 。

## 单调半格对象 monotonic semilattice object

对于一个基于状态的对象，如果满足：

1. 是一个半格。
1. **merge** 操作得到的结果是两个状态的 **最小上界**。
1. 对于任何 **update** 操作，得到的结果一定是不会下降的。

那么它就是一个**单调半格对象**。

## 小结

在所有操作最终都会投递和所有操作都会结束的条件下，
任意满足**单调半格**的基于状态的对象，
都满足**强最终一致性**。

# 基于操作的、可交换的、多副本的数据类型 (Op-based Commutative Replicated Data Type) CmRDT

## 用操作来描述一个对象

除了用状态去描述，还可以用操作来描述一个多副本的对象。

用操作描述对象可以表示为一个元组$(S, s^0, q, t, u, P)$：

1. $S, s^0, q$ 与用状态描述的对象是相同的。
1. 没有$merge$和$update$方法，作为替代的，$update$方法被拆分成$t$(*prepare-update*)和$u$(*effect-update*)。
    
    对于一个更新，在其触发的节点（称为**源** source）首先执行prepare-update，
    随后，effect-update会立即执行。

    在**源**更新完成之后，会依照**投送关系** (delivery relation) $P$，
    将effect-update投递给后续节点（称为**下游** downstream）。

1. $P$是一个投递的前置条件，举个例子，投递$u$给副本$i$会被阻塞直到$P(s\_i, u) = true$。

我们复用CvRDT的状态和因果史的符号表示，特别的，$f$现在可以表示$q,t,u$。

另外，和查询方法一样，prepare-update方法也是无副作用的(*side-effect-free*)。

## 基于操作的因果史与网络通信

因果史、先行发生的定义与基于状态描述的类似。

我们假定底层通信是一个可靠的、保持因果顺序的广播协议。

这种广播协议是一个分布式系统的标准特性，
能够在不要求达成共识的情况下，
会将所有的更新（按照因果顺序）投递给所有**正确的**进程（只要网络最终会恢复）。

由通信协议提供的保证，我们能够得出
如果两个更新是先行发生关系，那么在所有的节点上，两个更新都是先行发生的。

但并发的更新会被无序的投递。

## 基于操作的对象能够汇聚的充分条件

> 交换律
> 
> 对于两个更新$(t,u)$和$(t',u')$，当且仅当，对于任何副本的状态$s$有：
> 1. $u$ 和 $u'$ 都**可用** (enabled)
> 1. 状态 $s \\cdot u'(resp.s \\cdot u)$ 对于 $u(resp.u')$ 是**可用**的
> 1. 满足 $s \\cdot u \\cdot u' \\equiv s \\cdot u' \\cdot u$

显然的，一个基于操作描述的对象能够满足强汇聚性的条件是
所有的并发更新是满足交换律的。

## 小结

在所有操作都会结束和更新操作保持因果关系的投递的情况下，
任何由操作描述的对象，满足：

1. 任何并发更新都是可交换的
1. 投递前置条件能够由因果投递(causal delivery)满足

有强最终一致性。

# 名词速查

1. join semilattice
    
    对于一个偏序集$\\{S, \\leq\\}$，
    集合$S$的任意一对元素，
    有**最小上界**，
    则称该偏序集为一个**并半格**。

# 参考资料

- [Conflict-free Replicated Data Types](https://hal.inria.fr/hal-00932836/file/CRDTs_SSS-2011.pdf)
